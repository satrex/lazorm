using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using CommandLine;
using CommandLine.Text;
using Lazorm;
using LazormBoilerplate;
using LazormPageGenerator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.Extensions.Options;
using MySqlX.XDevAPI.Relational;

namespace Lazorm
{
    enum DbKind 
    {
        SqlServer, mssql, mySql, MySql, mysql, Oracle, oracle, SqLite, SQLite, sqLite, sqlite
    }

    [Verb("show", HelpText = "")]
    class ShowOptions
    {
        [Option('c', "connectionstring", HelpText = "Specify connection string to database.")]
        public string ConnectionString{ get; set; }

        [Option('j', "appsettingsjson", HelpText = "Specify appsettings.json file to connect database.")]
        public string AppsettingsJson { get; set; }

        [Option('k', "dbkind", HelpText = "Speciry Database Kind out of: SqlServer, MySq], Oracle, SqLite")]
        public DbKind DatabaseKind { get; set; }

        [Option('n', "namespace", HelpText = "Speciry namespace of generated classes. Lazorm by default.")]
        public string Namespace { get; set; } = "Lazorm";

        [Option('o', "output", HelpText = "Specify output directory. By default ./Entities/AutoGenerated ")]
        public string OutputDir { get; set; } = "./";

        [Option('t', "tables", HelpText = "Specify tables to process. By default, we process all tables in schema.")]
        public IEnumerable<string> Tables { get; set; }

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;

         //normal options here
        [Value(1, Default = "tables", HelpText = "Specify object by tables, columns (tables by default)", Required = true)]
        public string Value { get; set; }
    }
    
    [Verb("generate",isDefault:true, aliases:new[] { "g", "" }, HelpText = "Generates either of entity model, validation model, razor page, or fluxor stores.")]
    class GenerateOptions
    {
        [Option('m', "model", Required = false, HelpText = "Generates OR Mapper model class.You should specify output flag at least 1 out of -m|-v|-f|-r .")]
        public bool Mapper { get; set; }

        [Option('v', "validation", Required = false, HelpText = "Generates model validation (model omit keys ).You should specify output flag at least 1 out of -m|-v|-f|-r .")]
        public bool Validation { get; set; }

        [Option('f', "fluxor", Required = false, HelpText = "Generates Fluxor store set.You should specify output flag at least 1 out of -m|-v|-f|-r .")]
        public bool Fluxor { get; set; }

        [Option('p', "page", Required = false, HelpText = "Generates razor page.You should specify output flag at least 1 out of -m|-v|-f|-r .")]
        public bool RazorPage { get; set; }

        [Option('c', "connectionstring", HelpText = "Specify connection string to database. Required for model, validation, fluxor")]
        public string ConnectionString { get; set; }

        [Option('j', "appsettingsjson", HelpText = "Specify appsettings.json file to save connectionstring.")]
        public string AppsettingsJson { get; set; }

        [Option('k', "dbkind", HelpText = "Speciry Database Kind out of: SqlServer, MySq], Oracle, SqLite")]
        public DbKind DatabaseKind { get; set; } = DbKind.SqlServer;

        [Option('n', "namespace", HelpText = "Speciry namespace of generated classes. Lazorm by default.")]
        public string Namespace { get; set; } = "Lazorm";

        [Option('o', "output", HelpText = "Specify output directory with relative path from currnt directory. By default ./Entities/AutoGenerated ")]
        public string OutputDir { get; set; }

        [Option('t', "tables", HelpText = "Specify tables to process. If not specified, all tables in schema will be generated. Optional with fluxor(Either source or table).")]
        public IEnumerable<string> Tables { get; set; }

        [Option('s', "source", HelpText = "Specify source file to create razor page or fluxor. Required with razor page. Optional with fluxor.")]
        public IEnumerable<string> SourceFilePath { get; set; }

        [Option("page-wasm", HelpText = "If set true it creates page for blazor wasm (By default it creates blazor server page). Only works with generating razor page (Ignored with any other output).")]
        public bool PageIsWasmClient { get; set; } = false;

        [Option("page-uses-fluxor", HelpText = "If set true it creates page with fluxor. Only works with generating razor page (Ignored with any other output).")]
        public bool PageUsesFluxor { get; set; } = false;

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;
        public IEnumerable<string> ChildrenSourceFilePath { get; internal set; }
    }

    [Verb("generate-model", isDefault: false, aliases: new[] { "gm", "gmodel", "generate-entity", "ge", "gentity" } ,HelpText = "Generates entity class(es) from database tables.")]
    class GenerateModelOptions
    {
        [Option('v', "with-validation", Required = false, HelpText = "Generates also model validation (model omit keys ) in addition.")]
        public bool WithValidation { get; set; }

        [Option('c', "connectionstring", HelpText = "Specify connection string to database. Required for model, validation, fluxor")]
        public string ConnectionString { get; set; }

        [Option('j', "appsettingsjson", HelpText = "Specify appsettings.json file to save connectionstring.")]
        public string AppsettingsJson { get; set; }

        [Option('k', "dbkind", HelpText = "Speciry Database Kind out of: SqlServer, MySq], Oracle, SqLite")]
        public DbKind DatabaseKind { get; set; } = DbKind.SqlServer;

        [Option('n', "namespace", HelpText = "Speciry namespace of generated classes. Lazorm by default.")]
        public string Namespace { get; set; } = "Lazorm";

        [Option('o', "output", HelpText = "Specify output directory with relative path from currnt directory. By default ./Entities/AutoGenerated ")]
        public string OutputDir { get; set; }

        [Option('t', "tables", HelpText = "Specify tables to process. If not specified, all tables in schema will be generated. Optional with fluxor(Either source or table).")]
        public IEnumerable<string> Tables { get; set; }

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;
    }

    [Verb("generate-validation", isDefault: false, aliases: new[] { "gv", "gvalid", "generate-validation" }, HelpText = "Generates entity validation class(es) from database tables.")]
    class GenerateValidationOptions
    {
        [Option('c', "connectionstring", HelpText = "Specify connection string to database. Required for model, validation, fluxor")]
        public string ConnectionString { get; set; }

        [Option('j', "appsettingsjson", HelpText = "Specify appsettings.json file to save connectionstring.")]
        public string AppsettingsJson { get; set; }

        [Option('k', "dbkind", HelpText = "Speciry Database Kind out of: SqlServer, MySq], Oracle, SqLite")]
        public DbKind DatabaseKind { get; set; } = DbKind.SqlServer;

        [Option('n', "namespace", HelpText = "Speciry namespace of generated classes. Lazorm by default.")]
        public string Namespace { get; set; } = "Lazorm";

        [Option('o', "output", HelpText = "Specify output directory with relative path from currnt directory. By default ./Entities/AutoGenerated ")]
        public string OutputDir { get; set; }

        [Option('t', "tables", HelpText = "Specify tables to process. If not specified, all tables in schema will be generated. Optional with fluxor(Either source or table).")]
        public IEnumerable<string> Tables { get; set; }

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;
    }

    [Verb("generate-page", isDefault:false, aliases:new[]{"gp", "gpage"}, HelpText = "Record changes to the repository.")]
    class GeneratePageOptions
    {
        [Option('n', "namespace", HelpText = "Speciry namespace of generated classes. Lazorm by default.")]
        public string Namespace { get; set; } = "Lazorm";

        [Option('o', "output", HelpText = "Specify output directory with relative path from currnt directory. By default ./Entities/AutoGenerated ")]
        public string OutputDir { get; set; }

        [Option('s', "source", HelpText = "Specify source file(s) to create razor page or fluxor. Required with razor page. Optional with fluxor.")]
        public IEnumerable<string> SourceFilePath { get; set; }

        [Option("page-wasm", HelpText = "If set true it creates page for blazor wasm (By default it creates blazor server page). Only works with generating razor page (Ignored with any other output).")]
        public bool PageIsWasmClient { get; set; } = false;

        [Option("page-uses-fluxor", HelpText = "If set true it creates page with fluxor. Only works with generating razor page (Ignored with any other output).")]
        public bool PageUsesFluxor { get; set; } = false;

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;

        [Option("children", HelpText = "specify children classes to create tables in each detail page")]
        public IEnumerable<string> ChildrenSourceFilePath { get; set; }

    }

    [Verb("generate-fluxor", isDefault: false, aliases: new[] { "gf", "gfluxor" }, HelpText = "Generates fluxor store files. You can specify either database tables or source files.")]
    class GenerateFluxorOptions
    {
        [Option('n', "namespace", HelpText = "Speciry namespace of generated classes. Lazorm by default.")]
        public string Namespace { get; set; } = "Lazorm";

        [Option('o', "output", HelpText = "Specify output directory with relative path from currnt directory. By default ./Entities/AutoGenerated ")]
        public string OutputDir { get; set; }

        [Option('t', "tables", HelpText = "Specify tables to process. If not specified, all tables in schema will be generated. Optional with fluxor(Either source or table).")]
        public IEnumerable<string> Tables { get; set; }

        [Option('s', "sources", HelpText = "Specify source file to create razor page or fluxor. Required with razor page. Optional with fluxor.")]
        public IEnumerable<string> SourceFilePath { get; set; }

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;
    }

    [Verb("boilerplate", HelpText = "Record changes to the repository.")]
    class BoilerplateOptions
    {
        [Option('f', "fluxor", Required = false, HelpText = "Generates boilerplates of Fluxor.")]
        public bool Fluxor { get; set; }        

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;
    }
    /// <summary>
    /// Provides argument parsing in command line. 
    /// </summary>
    public class CliParser
    {
        /// <summary>
        /// Parses command line arguments. 
        /// </summary>
        /// <param name="args">command line arguments separated by whitespace</param>
        /// <exception cref="ArgumentException">Something wrong on argument</exception>
        public static void Parse(string[] args)
        {
            GenerateOptions generateOptions = null;
            ShowOptions showOptions = null;
            var parsed = Parser.Default.ParseArguments<GenerateOptions, GenerateModelOptions, GenerateValidationOptions, GenerateFluxorOptions,GeneratePageOptions, ShowOptions, BoilerplateOptions>(args);
            parsed.WithParsed<GenerateModelOptions>(opt => {
                generateOptions = new GenerateOptions()
                {
                    AppsettingsJson = opt.AppsettingsJson,
                    ConnectionString = opt.ConnectionString,
                    DatabaseKind = opt.DatabaseKind,
                    Namespace = opt.Namespace,
                    OutputDir = opt.OutputDir,
                    Tables = opt.Tables,
                    Verbose = opt.Verbose
                };
                GenerateModel(generateOptions);

                if(opt.WithValidation)
                {
                    GenerateValidation(generateOptions);
                }
            });
            parsed.WithParsed<GenerateValidationOptions>(opt => {
                generateOptions = new GenerateOptions()
                {
                    AppsettingsJson = opt.AppsettingsJson,
                    ConnectionString = opt.ConnectionString,
                    DatabaseKind = opt.DatabaseKind,
                    Namespace = opt.Namespace,
                    OutputDir = opt.OutputDir,
                    Tables = opt.Tables,
                    Verbose = opt.Verbose
                };
                GenerateValidation(generateOptions);                
            });
            parsed.WithParsed<GeneratePageOptions>(opt => {
                generateOptions = new GenerateOptions()
                {
                    SourceFilePath = opt.SourceFilePath,
                    Namespace = opt.Namespace,
                    OutputDir = opt.OutputDir,
                    PageUsesFluxor = opt.PageUsesFluxor,
                    PageIsWasmClient = opt.PageIsWasmClient,
                    Verbose = opt.Verbose,
                    ChildrenSourceFilePath = opt.ChildrenSourceFilePath
                };
                GenerateRazorPage(generateOptions);
            });
	        parsed.WithParsed<GenerateFluxorOptions>(opt => {
                generateOptions = new GenerateOptions()
                {
                    SourceFilePath = opt.SourceFilePath,
                    Namespace = opt.Namespace,
                    OutputDir = opt.OutputDir,
                    Tables = opt.Tables,
                    Verbose = opt.Verbose
                };
                GenerateFluxor(generateOptions);
            });
            parsed.WithParsed<GenerateOptions>(opt =>
            {

                if ((opt.Mapper | opt.Validation | opt.Fluxor | opt.RazorPage) == false)
                    throw new ArgumentException("You should specify output flag at least 1 out of -m|-v|-f|-r .");

                if (opt.Verbose)
                    Trace.Listeners.Add(new ConsoleTraceListener());

                generateOptions = opt;
                if (generateOptions != null)
                {
                    if (generateOptions.Mapper)
                        GenerateModel(generateOptions);
                    if (generateOptions.Validation)
                        GenerateValidation(generateOptions);
                    if (generateOptions.Fluxor)
                        GenerateFluxor(generateOptions);
                    if (generateOptions.RazorPage)
                        GenerateRazorPage(generateOptions);
                }

                return;
            });
            parsed.WithParsed<ShowOptions>(opt =>
            {
                showOptions = opt;

                if (showOptions != null)
                    ProcessShowCommand(showOptions);
            });
            parsed.WithParsed<BoilerplateOptions>(opt => {
                if (opt.Verbose)
                    Trace.Listeners.Add(new ConsoleTraceListener());

                if (opt.Fluxor)
                {
                    FluxorBoilerplate.WriteInNeed();
                }
            });
            parsed.WithNotParsed(er =>
            {
                // パース結果からデフォルトの文を生成したい場合は、HelpText.AutoBuildを使用する
                var helpText = "argument is invalid";
                // 生成後にhelpText = helpText.Add...で追加記述も可能
                Console.WriteLine($"parse failed: {helpText}");
                return;
            });


        }

        private static void GenerateRazorPage(GenerateOptions options)
        {
            Trace.WriteLine("CliParser.GenerateRazorPage started");
            if (options.SourceFilePath is null || options.SourceFilePath.Count() == 0)
                throw new ArgumentNullException("Please specify source file if creating razor page");

            var outFolder = PrepareOutputFolderForPage(options);

            foreach(var sourceFile in options.SourceFilePath)
            {
                try
                {
                    PageGenerator.GeneratePageFromFile(sourceFile, outFolder, options.Namespace, options.PageUsesFluxor, options.PageIsWasmClient, options.ChildrenSourceFilePath);
                }
                catch(Exception e)
                {
                    Trace.TraceError($"{e.GetType().Name}\n{e.Message}");
                }
            }

        }

        private static void GenerateFluxor(GenerateOptions generateOptions)
        {
            if (generateOptions.OutputDir is null)
                generateOptions.OutputDir = "Lazorm";

            var outdir = Path.Combine(Environment.CurrentDirectory, generateOptions.OutputDir);
            if (!Directory.Exists(outdir))
                Directory.CreateDirectory(outdir);

            foreach (var table in generateOptions.Tables)
            {
                LazormFluxorGenerator.Generator.Run(table, outdir, generateOptions.Namespace);
            }

            foreach (var sourceFile in generateOptions.SourceFilePath)
            {
                try
                {
                    var className = GetClassName(sourceFile);
                    LazormFluxorGenerator.Generator.Run(className, outdir, namespaceText: generateOptions.Namespace);

                }
                catch (Exception e)
                {
                    Trace.TraceError($"{e.GetType().Name}\n{e.Message}");
                }
            }

        }

        public static string GetClassName(string filePath)
        {
            // ソースコードをテキストとして読み込む
            var code = File.ReadAllText(filePath);

            List<SyntaxTree> syntaxTrees = new List<SyntaxTree>();
            // 構文木の生成

            var syntaxTree = CSharpSyntaxTree.ParseText(code, CSharpParseOptions.Default, filePath);
            // 構文木をリストへ格納
            syntaxTrees.Add(syntaxTree);

            var compilation = CSharpCompilation.Create("lazorm", syntaxTrees, null);

            var pluralizer = new Pluralize.NET.Pluralizer();

            Trace.WriteLine("Parsing source file...");
            #region Source File Parsing
            foreach (var tree in syntaxTrees)
            {
                // コンパイラからセマンティックモデルの取得
                var semanticModel = compilation.GetSemanticModel(tree);
                // 構文木からルートの子ノード群を取得
                var nodes = tree.GetRoot().DescendantNodes();

                // ノード群からクラスに関する構文情報群を取得
                // クラスはClassDeclarationSyntax
                // インタフェースはInterfaceDeclarationSyntax
                // 列挙型はEnumDeclarationSyntax
                // 構造体はStructDeclarationSyntax
                // デリゲートはDelegateDeclarationSyntax
                var classSyntaxArray = nodes.OfType<ClassDeclarationSyntax>();
                foreach (var syntax in classSyntaxArray)
                {
                    var symbol = semanticModel.GetDeclaredSymbol(syntax);
                    Trace.WriteLine("{symbol!.DeclaredAccessibility} {symbol}");
                    Trace.WriteLine(" {nameof(symbol.IsAbstract)}: {symbol.IsAbstract}");
                    Trace.WriteLine(" {nameof(symbol.IsStatic)}: {symbol.IsStatic}");
                    if (symbol!.Name == Path.GetFileNameWithoutExtension(filePath))
                    {
                        return symbol.Name.Capitalize();
                    }
                }
            }
            #endregion
            throw new ArgumentException($"Can't find class name in source file {filePath}");
        }


        private static void GenerateValidation(GenerateOptions options)
        {
            var outFolder = PrepareOutputFolderForValidation(options);
            Database db = Database.CreateInstance(options.DatabaseKind.ToString().ToLower(), options.ConnectionString);

            var keyName = string.Format("{0}Key", db.Schema);
            var generator = new DataValidationGenerator(options.Namespace, db, keyName);
            var tables = new List<string>();

            // if tables not specified, then go all tables
            if (0 < options.Tables?.Count())
            {
                tables.AddRange(options.Tables);
            }
            else
            {
                db.GetTableDefs().ForEach(t =>
                    tables.Add(t.Name)
                );
            }
            tables.ForEach(t =>
            {
                generator.Generate(t, outFolder);
            });
        }

        private static void GenerateModel(GenerateOptions options)
        {

            var outFolder = PrepareOutputFolderForEntity(options);
            Database db = Database.CreateInstance(options.DatabaseKind.ToString().ToLower(), options.ConnectionString);

            var keyName = string.Format("{0}Key", db.Schema);
            var generator = new DataEntityGenerator(options.Namespace, db, keyName);
            var tables = new List<string>();

            // if tables not specified, then go all tables
            if (0 < options.Tables?.Count())
            {
                tables.AddRange(options.Tables);
            }
            else
            {
                db.GetTableDefs().ForEach(t =>
                    tables.Add(t.Name)
                );
            }
            tables.ForEach(t =>
            {
                generator.Generate(t, outFolder);
            });

            JsonSettingWriter.SetAppSettingValue(keyName, options.ConnectionString,
                options.AppsettingsJson);
            LazormBoilerplate.CommandExecutor.InstallLazormlib();
        }
        private static string PrepareOutputFolderForValidation(GenerateOptions options)
        {
            var outFolder = Path.Combine(Environment.CurrentDirectory, "Entities", "Validation");
            if (!String.IsNullOrWhiteSpace(options.OutputDir))
            {
                outFolder = options.OutputDir;
                Console.WriteLine("Output directory is specified: {0}", outFolder);
            }

            // Creates folder if not exists
            if (!Directory.Exists(outFolder))
            {
                Directory.CreateDirectory(outFolder);
            }
            return outFolder;
        }

        private static string PrepareOutputFolderForPage(GenerateOptions options)
        {
            return PrepareOutputFolder(options, "Pages");
        }

        private static string PrepareOutputFolderForContollers(GenerateOptions options)
        {
            return PrepareOutputFolder(options, "Controllers");
        }

        private static string PrepareOutputFolder(GenerateOptions options, string FolderName)
        {
            var outFolder = Path.Combine(Environment.CurrentDirectory, FolderName);
            if (!String.IsNullOrWhiteSpace(options.OutputDir))
            {
                outFolder = options.OutputDir;
                Console.WriteLine("Output directory is specified: {0}", outFolder);
            }

            // Creates folder if not exists
            if (!Directory.Exists(outFolder))
            {
                Directory.CreateDirectory(outFolder);
            }
            return outFolder;
        }


        private static string PrepareOutputFolderForEntity(GenerateOptions options)
        {
            var outFolder = Path.Combine(Environment.CurrentDirectory, "Entities", "AutoGenerated");
            if (!String.IsNullOrWhiteSpace(options.OutputDir))
            {
                outFolder = options.OutputDir;
                Console.WriteLine("Output directory is specified: {0}", outFolder);
            }

            // Creates folder if not exists
            if (!Directory.Exists(outFolder))
            {
                Directory.CreateDirectory(outFolder);
            }
            return outFolder;
        }

        private static void ProcessShowCommand(ShowOptions options)
        {
            Database db = Database.CreateInstance(options.DatabaseKind.ToString(), options.ConnectionString);

            if (options.Value == "tables")
            {
                Console.WriteLine("===  TABLE NAME  ===\n--------------------");
                db.GetTableDefs().ForEach(t =>
                    Console.WriteLine("{0} ", t.Name)
                );
            }
        }
    }
}
