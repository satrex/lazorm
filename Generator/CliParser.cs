using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using CommandLine;
using CommandLine.Text;
using Lazorm;
using LazormBoilerplate;
using Microsoft.Extensions.Options;

namespace Lazorm
{
    enum DbKind 
    {
        SqlServer, mssql, mySql, MySql, mysql, Oracle, oracle, SqLite, SQLite, sqLite, sqlite
    }

    [Verb("show", HelpText = "")]
    class ShowOptions
    {
        [Option('c', "connectionstring", HelpText = "Specify connection string to database.")]
        public string ConnectionString{ get; set; }

        [Option('j', "appsettingsjson", HelpText = "Specify appsettings.json file to connect database.")]
        public string AppsettingsJson { get; set; }

        [Option('k', "dbkind", HelpText = "Speciry Database Kind out of: SqlServer, MySq], Oracle, SqLite")]
        public DbKind DatabaseKind { get; set; }

        [Option('n', "namespace", HelpText = "Speciry namespace of generated classes. Lazorm by default.")]
        public string Namespace { get; set; } = "Lazorm";

        [Option('o', "output", HelpText = "Specify output directory. By default ./Entities/AutoGenerated ")]
        public string OutputDir { get; set; } = "./";

        [Option('t', "tables", HelpText = "Specify tables to process. By default, we process all tables in schema.")]
        public IEnumerable<string> Tables { get; set; }

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;

         //normal options here
        [Value(1, Default = "tables", HelpText = "Specify object by tables, columns (tables by default)", Required = true)]
        public string Value { get; set; }
    }
    
    [Verb("generate", HelpText = "Record changes to the repository.")]
    class GenerateOptions
    {
        [Option('m', "model", Required = false, HelpText = "Generates OR Mapper model class.")]
        public bool Mapper { get; set; }

        [Option('v', "validation", Required = false, HelpText = "Generates model validation (model omit keys)")]
        public bool Validation { get; set; }

        [Option('f', "fluxor", Required = false, HelpText = "Generates Fluxor store set.")]
        public bool Fluxor { get; set; }

        [Option('p', "page", Required = false, HelpText = "Generates razor page")]
        public bool RazorPage { get; set; }

        [Option('c', "connectionstring", HelpText = "Specify connection string to database. Required for model, validation, fluxor")]
        public string ConnectionString { get; set; }

        [Option('j', "appsettingsjson", HelpText = "Specify appsettings.json file to save connectionstring.")]
        public string AppsettingsJson { get; set; }

        [Option('k', "dbkind", HelpText = "Speciry Database Kind out of: SqlServer, MySq], Oracle, SqLite")]
        public DbKind DatabaseKind { get; set; } = DbKind.SqlServer;

        [Option('n', "namespace", HelpText = "Speciry namespace of generated classes. Lazorm by default.")]
        public string Namespace { get; set; } = "Lazorm";

        [Option('o', "output", HelpText = "Specify output directory with relative path from currnt directory. By default ./Entities/AutoGenerated ")]
        public string OutputDir { get; set; }

        [Option('t', "tables", HelpText = "Specify tables to process. By default, we process all tables in schema.")]
        public IEnumerable<string> Tables { get; set; }

        [Option('s', "page-source", HelpText = "Specify source file to create razor page. Required with razor page.")]
        public string SourceFilePath { get; set; }

        [Option("page-wasm", HelpText = "If set true it creates page for blazor wasm (By default it creates blazor server page). Only works with generating razor page (Ignored with any other output).")]
        public bool PageIsWasmClient { get; set; } = false;

        [Option("page-uses-fluxor", HelpText = "If set true it creates page with fluxor. Only works with generating razor page (Ignored with any other output).")]
        public bool PageUsesFluxor { get; set; } = false;

        [Option("verbose", HelpText = "If set true, it shows detailed log")]
        public bool Verbose { get; set; } = false;
    }
    [Verb("boilerplate", HelpText = "Record changes to the repository.")]
    class BoilerplateOptions
    {
        [Option('f', "fluxor", Required = false, HelpText = "Generates boilerplates of Fluxor.")]
        public bool Fluxor { get; set; }        
    }
    /// <summary>
    /// Provides argument parsing in command line. 
    /// </summary>
    public class CliParser
    {
        /// <summary>
        /// Parses command line arguments. 
        /// </summary>
        /// <param name="args">command line arguments separated by whitespace</param>
        /// <exception cref="ArgumentException">Something wrong on argument</exception>
        public static void Parse(string[] args)
        {
            GenerateOptions generateOprions = null;
            ShowOptions showOptions = null;
            var parsed = Parser.Default.ParseArguments<GenerateOptions, ShowOptions, BoilerplateOptions>(args);
            parsed.WithParsed<GenerateOptions>(opt =>
            {

                if ((opt.Mapper | opt.Validation | opt.Fluxor | opt.RazorPage) == false)
                    throw new ArgumentException("You should specify output flag at least 1 out of -m|-v|-f|-r .");

                if (opt.Verbose)
                    Trace.Listeners.Add(new ConsoleTraceListener());

                generateOprions = opt;
                if (generateOprions != null)
                {
                    if (generateOprions.Mapper)
                        GenerateModel(generateOprions);
                    if (generateOprions.Validation)
                        GenerateValidation(generateOprions);
                    if (generateOprions.Fluxor)
                        GenerateFluxor(generateOprions);
                    if (generateOprions.RazorPage)
                        GenerateRazorPage(generateOprions);
                }
                return;
            });
            parsed.WithParsed<ShowOptions>(opt =>
            {
                showOptions = opt;

                if (showOptions != null)
                    ProcessShowCommand(showOptions);
            });
            parsed.WithParsed<BoilerplateOptions>(opt => {
                if(opt.Fluxor)
                {
                    FluxorBoilerplate.WriteInNeed();
                }
            });
            parsed.WithNotParsed(er =>
            {
                // パース結果からデフォルトの文を生成したい場合は、HelpText.AutoBuildを使用する
                var helpText = "argument is invalid";
                // 生成後にhelpText = helpText.Add...で追加記述も可能
                Console.WriteLine($"parse failed: {helpText}");
                return;
            });


        }

        private static void GenerateRazorPage(GenerateOptions options)
        {
            Trace.WriteLine("CliParser.GenerateRazorPage started");
            if (string.IsNullOrWhiteSpace(options.SourceFilePath))
                throw new ArgumentNullException("Please specify source file if creating razor page");

            var outFolder = PrepareOutputFolderForPage(options);

            // generate page without fluxor
            LazormPageGenerator.PageGenerator.GenerateFromFile(options.SourceFilePath, outFolder, options.Namespace, options.PageUsesFluxor, options.PageIsWasmClient);


            //Database db = Database.CreateInstance(options.DatabaseKind.ToString().ToLower(), options.ConnectionString);
            //Trace.WriteLine("db proxy created");

            //var keyName = string.Format("{0}Key", db.Schema);
            //var generator = new DataEntityGenerator(options.Namespace, db, keyName);
            //var tables = new List<string>();

            //// if tables not specified, then go all tables
            //if (0 < options.Tables?.Count())
            //{
            //    tables.AddRange(options.Tables);
            //}
            //else
            //{

            //    throw new ArgumentNullException("Please specify table to create razor page.");
            //}
            //tables.ForEach(t => {
            //    generator.Generate(t, outFolder);
            //}); ;
        }

        private static void GenerateFluxor(GenerateOptions generateOprions)
        {
            if (generateOprions.OutputDir is null)
                generateOprions.OutputDir = "Lazorm";

            var outdir = Path.Combine(Environment.CurrentDirectory, generateOprions.OutputDir);
            if (!Directory.Exists(outdir))
                Directory.CreateDirectory(outdir);

            foreach (var table in generateOprions.Tables)
            {
                LazormFluxorGenerator.Generator.Run(table, outdir);
            }
        }

        private static void GenerateValidation(GenerateOptions options)
        {
            var outFolder = PrepareOutputFolderForValidation(options);
            Database db = Database.CreateInstance(options.DatabaseKind.ToString().ToLower(), options.ConnectionString);

            var keyName = string.Format("{0}Key", db.Schema);
            var generator = new DataValidationGenerator(options.Namespace, db, keyName);
            var tables = new List<string>();

            // if tables not specified, then go all tables
            if (0 < options.Tables?.Count())
            {
                tables.AddRange(options.Tables);
            }
            else
            {
                db.GetTableDefs().ForEach(t =>
                    tables.Add(t.Name)
                );
            }
            tables.ForEach(t =>
            {
                generator.Generate(t, outFolder);
            });
        }

        private static void GenerateModel(GenerateOptions options)
        {

            var outFolder = PrepareOutputFolderForEntity(options);
            Database db = Database.CreateInstance(options.DatabaseKind.ToString().ToLower(), options.ConnectionString);

            var keyName = string.Format("{0}Key", db.Schema);
            var generator = new DataEntityGenerator(options.Namespace, db, keyName);
            var tables = new List<string>();

            // if tables not specified, then go all tables
            if (0 < options.Tables?.Count())
            {
                tables.AddRange(options.Tables);
            }
            else
            {
                db.GetTableDefs().ForEach(t =>
                    tables.Add(t.Name)
                );
            }
            tables.ForEach(t =>
            {
                generator.Generate(t, outFolder);
            });

            JsonSettingWriter.SetAppSettingValue(keyName, options.ConnectionString,
                options.AppsettingsJson);

        }
        private static string PrepareOutputFolderForValidation(GenerateOptions options)
        {
            var outFolder = Path.Combine(Environment.CurrentDirectory, "Entities", "Validation");
            if (!String.IsNullOrWhiteSpace(options.OutputDir))
            {
                outFolder = options.OutputDir;
                Console.WriteLine("Output directory is specified: {0}", outFolder);
            }

            // Creates folder if not exists
            if (!Directory.Exists(outFolder))
            {
                Directory.CreateDirectory(outFolder);
            }
            return outFolder;
        }

        private static string PrepareOutputFolderForPage(GenerateOptions options)
        {
            return PrepareOutputFolder(options, "Pages");
        }

        private static string PrepareOutputFolderForContollers(GenerateOptions options)
        {
            return PrepareOutputFolder(options, "Controllers");
        }

        private static string PrepareOutputFolder(GenerateOptions options, string FolderName)
        {
            var outFolder = Path.Combine(Environment.CurrentDirectory, FolderName);
            if (!String.IsNullOrWhiteSpace(options.OutputDir))
            {
                outFolder = options.OutputDir;
                Console.WriteLine("Output directory is specified: {0}", outFolder);
            }

            // Creates folder if not exists
            if (!Directory.Exists(outFolder))
            {
                Directory.CreateDirectory(outFolder);
            }
            return outFolder;
        }


        private static string PrepareOutputFolderForEntity(GenerateOptions options)
        {
            var outFolder = Path.Combine(Environment.CurrentDirectory, "Entities", "AutoGenerated");
            if (!String.IsNullOrWhiteSpace(options.OutputDir))
            {
                outFolder = options.OutputDir;
                Console.WriteLine("Output directory is specified: {0}", outFolder);
            }

            // Creates folder if not exists
            if (!Directory.Exists(outFolder))
            {
                Directory.CreateDirectory(outFolder);
            }
            return outFolder;
        }

        private static void ProcessShowCommand(ShowOptions options)
        {
            Database db = Database.CreateInstance(options.DatabaseKind.ToString(), options.ConnectionString);

            if (options.Value == "tables")
            {
                Console.WriteLine("===  TABLE NAME  ===\n--------------------");
                db.GetTableDefs().ForEach(t =>
                    Console.WriteLine("{0} ", t.Name)
                );
            }
        }
    }
}
